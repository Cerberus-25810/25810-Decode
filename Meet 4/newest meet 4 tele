package org.firstinspires.ftc.teamcode;

import static org.firstinspires.ftc.teamcode.pedroPathing.Tuning.follower;

import com.pedropathing.geometry.Pose;
import com.pedropathing.math.MathFunctions;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.PwmControl;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.ServoImplEx;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range;

import org.firstinspires.ftc.teamcode.pedroPathing.Constants;

import java.util.TreeMap;


@TeleOp(name = "fulltel", group = "Competition")
public class fulltel extends OpMode {

    // ===== FIELD POSITIONS =====
    private final Pose startPose =
            new Pose(21.792, 124.3442, Math.toRadians(143));

    private static final double GOAL_X = 10;
    private static final double GOAL_Y = 137;

    // Shooter offset from robot center (in robot frame)
    private static final double SHOOTER_OFFSET_X = 0.0;
    private static final double SHOOTER_OFFSET_Y = 0.0;

    // ===== HEADING LOCK SYSTEM (A button) =====
    private static final double LOCK_KP = 3.0;  // PD gains for heading lock
    private static final double LOCK_KD = 0.1;

    // Dynamic offset based on Y position
    private static final double HEADING_OFFSET_DEFAULT = Math.toRadians(5);  // 5 degrees left offset (default)
    private static final double HEADING_OFFSET_FAR_SHOT = Math.toRadians(1.7); // 1.7 degrees right offset (for far shots)
    private static final double Y_THRESHOLD = 47.6439169139466;  // Y coordinate threshold for switching offsets

    boolean headingLock = false;
    boolean lastA = false;
    private double targetHeading = Math.toRadians(180);
    private double headingError = 0;
    private double lastHeadingErrorLock = 0;
    private double headingErrorRate = 0;
    private ElapsedTime timer = new ElapsedTime();
    private double lastTime = 0;

    // ===== SHOOTER PID / FEEDFORWARD =====
    private static final double kP = 0.005, kI = 0.0, kD = 0.0, kF = 0.0;
    private static final double kV = 0.00035, kA = 0.0, kS = 0.065;

    // ===== HARDWARE =====
    private DcMotorEx Shooter, Shooter2;
    private DcMotor Intake, Control;
    private CRServo LeftServo, RightServo;
    private ServoImplEx Hood, Hood2;
    private Pidshootercontroller pidController;

    // ===== INTERPOLATION TABLES =====
    // Format: (distance, velocity) and (distance, hoodPosition)
    private static final TreeMap<Double, Double> velocityTable = new TreeMap<>();
    private static final TreeMap<Double, Double> hoodTable = new TreeMap<>();

    static {
        // Data format: (Distance, Velocity, Hood Position)
        addPoint(35, 1060, 0.1);
        addPoint(40, 1070, 0.18);
        addPoint(48, 1325, 0.33);
        addPoint(50, 1335, 0.35);
        addPoint(55, 1350, 0.37);
        addPoint(60, 1365, 0.38);
        addPoint(65, 1385, 0.38);
        addPoint(70, 1415, 0.38);
        addPoint(71, 1445, 0.38);
        addPoint(73, 1480, 0.39);
        addPoint(67, 1625, 0.35);
        addPoint(79, 1740, 0.36);
    }


    private static void addPoint(double dist, double vel, double hood) {
        velocityTable.put(dist, vel);
        hoodTable.put(dist, hood);
    }

    // ===== INIT =====

    @Override
    public void init() {
        follower = Constants.createFollower(hardwareMap);
        follower.setPose(startPose);

        initializeHardware();
        configureMotors();
        configureServos();

        pidController = new Pidshootercontroller(kP, kI, kD, kF);
        pidController.setFeedforward(kV, kA, kS);

        follower.update();

        telemetry.addData("Status", "Initialized");
        telemetry.addData("Heading Lock (A)", "PD auto-lock with dynamic offset");
        telemetry.update();
    }

    private void initializeHardware() {
        Shooter = hardwareMap.get(DcMotorEx.class, "Leftshooter");
        Shooter2 = hardwareMap.get(DcMotorEx.class, "Rightshooter");
        Intake = hardwareMap.get(DcMotor.class, "Intake");
        Control = hardwareMap.get(DcMotor.class, "Control");
        LeftServo = hardwareMap.get(CRServo.class, "LeftServo");
        RightServo = hardwareMap.get(CRServo.class, "RightServo");
        Hood = hardwareMap.get(ServoImplEx.class, "Hood");
        Hood2 = hardwareMap.get(ServoImplEx.class, "Hood2");
    }

    private void configureMotors() {
        Shooter2.setDirection(DcMotorSimple.Direction.FORWARD);
        Shooter.setDirection(DcMotorSimple.Direction.REVERSE);
        Control.setDirection(DcMotorSimple.Direction.REVERSE);
        RightServo.setDirection(DcMotorSimple.Direction.REVERSE);

        Shooter.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        Shooter2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    }

    private void configureServos() {
        Hood.setPwmRange(new PwmControl.PwmRange(500, 2500));
        Hood2.setPwmRange(new PwmControl.PwmRange(500, 2500));
        Hood.setDirection(Servo.Direction.FORWARD);
        Hood2.setDirection(Servo.Direction.REVERSE);
        LeftServo.setDirection(CRServo.Direction.FORWARD);
        RightServo.setDirection(CRServo.Direction.REVERSE);
    }

    // ===== START =====

    @Override
    public void start() {
        follower.startTeleopDrive();
        Control.setPower(0);
        Intake.setPower(0.1);
        LeftServo.setPower(-1);
        RightServo.setPower(-1);
        lastHeadingErrorLock = 0;
        timer.reset();
        lastTime = timer.seconds();
    }

    // ===== MAIN LOOP =====

    @Override
    public void loop() {
        follower.update();
        Pose pose = follower.getPose();

        // ---------- Toggle Heading Lock (A button) ----------
        boolean currentA = gamepad1.a;
        if (currentA && !lastA) {
            headingLock = !headingLock;
            if (headingLock) {
                lastHeadingErrorLock = 0;
            }
        }
        lastA = currentA;

        // ---------- Drivetrain ----------
        double drive = -gamepad1.left_stick_y * 0.8;
        double strafe = -gamepad1.left_stick_x * 0.8;
        double turn;

        if (headingLock) {
            // *** HEADING LOCK MODE (A button) ***
            // Recalculate target heading every loop based on current position
            targetHeading = calculateHeadingToGoalWithOffset();

            // Calculate heading error
            headingError = calculateHeadingError();

            // Calculate derivative (rate of change of error)
            double currentTime = timer.seconds();
            double deltaTime = currentTime - lastTime;
            if (deltaTime > 0) {
                headingErrorRate = (headingError - lastHeadingErrorLock) / deltaTime;
            }

            // PD Controller: output = Kp * error + Kd * error_rate
            turn = LOCK_KP * headingError + LOCK_KD * headingErrorRate;

            // Clamp turn power to [-1, 1]
            turn = Math.max(-1.0, Math.min(1.0, turn));

            // Update last values for next iteration
            lastHeadingErrorLock = headingError;
            lastTime = currentTime;

        } else {
            // *** MANUAL CONTROL ***
            turn = -gamepad1.right_stick_x * 0.8;
        }

        follower.setTeleOpDrive(drive, strafe, turn, true);

        // ---------- Shooter Speed + Hood (distance-based) ----------
        double distanceToGoal = Math.hypot(GOAL_X - pose.getX(), GOAL_Y - pose.getY());

        double targetVelocity = interpolate(velocityTable, distanceToGoal);
        double targetHoodPos = interpolate(hoodTable, distanceToGoal);

        Hood.setPosition(targetHoodPos);
        Hood2.setPosition(targetHoodPos);

        double currentVel = Shooter.getVelocity();
        double shooterPower = pidController.calculate(targetVelocity - currentVel, targetVelocity, 0);

        Shooter.setPower(Range.clip(shooterPower, -1, 1));
        Shooter2.setPower(Range.clip(shooterPower, -1, 1));

        // ---------- Intake / Control ----------
        if (gamepad1.right_trigger > 0.02) {
            Control.setPower(1);
            Intake.setPower(1);
            RightServo.setPower(1);
            LeftServo.setPower(1);
        } else {
            Control.setPower(0.7);
            Intake.setPower(0.9);
            RightServo.setPower(-1);
            LeftServo.setPower(-1);
        }

        // ---------- Telemetry ----------
        boolean isFarShot = pose.getY() < Y_THRESHOLD;
        double currentOffset = isFarShot ? HEADING_OFFSET_FAR_SHOT : HEADING_OFFSET_DEFAULT;

        String mode = headingLock ? "HEADING LOCK" : "MANUAL";

        telemetry.addData("Control Mode", mode);
        telemetry.addData("", "");
        telemetry.addData("Robot X", "%.2f", pose.getX());
        telemetry.addData("Robot Y", "%.2f", pose.getY());
        telemetry.addData("Robot Heading", "%.1f deg", Math.toDegrees(pose.getHeading()));
        telemetry.addData("", "");

        if (headingLock) {
            telemetry.addData("Shot Zone", isFarShot ? "FAR SHOT (Right Offset)" : "NORMAL (Left Offset)");
            telemetry.addData("Current Offset", "%.1fÂ°", Math.toDegrees(currentOffset));
            telemetry.addData("Target Heading", "%.1f deg", Math.toDegrees(targetHeading));
            telemetry.addData("Heading Error", "%.1f deg", Math.toDegrees(headingError));
            telemetry.addData("Error Rate", "%.3f", headingErrorRate);
            telemetry.addData("Turn Output", "%.3f", turn);
        }

        telemetry.addData("", "");
        telemetry.addData("Distance", "%.2f", distanceToGoal);
        telemetry.addData("Target Vel", "%.0f", targetVelocity);
        telemetry.addData("Current Vel", "%.0f", currentVel);
        telemetry.addData("Hood Pos", "%.2f", targetHoodPos);
        telemetry.addData("", "");
        telemetry.addData("Controls", "A: Heading Lock | RT: Shoot");
        telemetry.update();
    }

    // ===== HEADING LOCK HELPER METHODS =====

    /**
     * Calculate the heading from the robot's current position to the goal
     * Includes dynamic offset that changes based on Y position
     */
    private double calculateHeadingToGoalWithOffset() {
        Pose currentPose = follower.getPose();
        double dx = GOAL_X - currentPose.getX();
        double dy = GOAL_Y - currentPose.getY();

        // Calculate base heading to goal
        double baseHeading = Math.atan2(dy, dx);

        // Choose offset based on Y position
        // If Y < threshold (robot is in far shot zone), offset right (1.7Â°)
        // Otherwise, use default left offset (5Â°)
        double offset;
        if (currentPose.getY() < Y_THRESHOLD) {
            offset = HEADING_OFFSET_FAR_SHOT;  // Right offset for far shots
        } else {
            offset = HEADING_OFFSET_DEFAULT;   // Left offset for normal shots
        }

        return baseHeading + offset;
    }

    /**
     * Calculate signed heading error (shortest path to target)
     */
    private double calculateHeadingError() {
        double currentHeading = follower.getPose().getHeading();

        // Normalize both angles to [-Ï€, Ï€]
        double current = normalizeAngle(currentHeading);
        double target = normalizeAngle(targetHeading);

        // Calculate shortest angular difference
        double error = target - current;

        // Wrap to [-Ï€, Ï€]
        if (error > Math.PI) {
            error -= 2 * Math.PI;
        } else if (error < -Math.PI) {
            error += 2 * Math.PI;
        }

        return error;
    }

    /**
     * Normalize angle to [-Ï€, Ï€]
     */
    private double normalizeAngle(double angle) {
        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;
        return angle;
    }

    // ===== HELPER: Linear interpolation over a TreeMap =====

    /**
     * Performs linear interpolation between data points in a TreeMap.
     * Clamps to the nearest endpoint if the input is out of range.
     */
    private double interpolate(TreeMap<Double, Double> table, double x) {
        if (table.isEmpty()) return 0;

        // Handle out-of-bounds (Clamp to nearest known point)
        if (x <= table.firstKey()) return table.get(table.firstKey());
        if (x >= table.lastKey()) return table.get(table.lastKey());

        // Get the two points surrounding 'x'
        Double lowKey = table.floorKey(x);
        Double highKey = table.ceilingKey(x);

        if (lowKey == null || highKey == null || lowKey.equals(highKey)) {
            return table.get(lowKey != null ? lowKey : highKey);
        }

        double lowVal = table.get(lowKey);
        double highVal = table.get(highKey);

        // Linear interpolation formula: y = y0 + (x - x0) * (y1 - y0) / (x1 - x0)
        return lowVal + (x - lowKey) * (highVal - lowVal) / (highKey - lowKey);
    }
}
