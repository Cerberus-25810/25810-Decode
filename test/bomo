package org.firstinspires.ftc.teamcode.Testnow;

import com.acmerobotics.dashboard.FtcDashboard;
import com.acmerobotics.dashboard.config.Config;
import com.acmerobotics.dashboard.telemetry.MultipleTelemetry;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.Gamepad;
import com.qualcomm.robotcore.hardware.VoltageSensor;

@Config
@TeleOp(name = "Flywheel Tuner", group = "Tuning")
public class bomo extends LinearOpMode {

    private DcMotorEx Shooter;
    private DcMotorEx Shooter2;
    private DcMotor Intake, Control;
    private CRServo LeftServo, RightServo;

    // ===== FTC DASHBOARD TUNABLE PARAMETERS =====

    // PID Coefficients
    public static double kP = 0;
    public static double kI = 0.0;
    public static double kD = 0;
    public static double kF = 0.0;

    // Feedforward Coefficients
    public static double kV = 0.0;
    public static double kA = 0.0;
    public static double kS = 0.0;

    // Target Velocities
    public static double targetVelocity = 1240.0;
    public static double velocityStep = 50.0;  // How much to change velocity with buttons

    // Controller tuning increments
    public static double kP_increment = 0.0;
    public static double kI_increment = 0.00;
    public static double kD_increment = 0.0;
    public static double kV_increment = 0.0000;
    public static double kS_increment = 0.00;

    // Other parameters
    public static double nominalVoltage = 12.5;
    public static boolean enableVoltageCompensation = true;

    // ===== RUNTIME VARIABLES =====
    private newPIDFController flywheelController;
    private double velocity1, velocity2;
    private double batteryVoltage;
    private Gamepad currentGamepad1 = new Gamepad();
    private Gamepad previousGamepad1 = new Gamepad();

    // Tuning mode (what parameter we're adjusting)
    private enum TuningMode {
        TARGET_VELOCITY,
        KP,
        KI,
        KD,
        KV,
        KS
    }
    private TuningMode currentMode = TuningMode.TARGET_VELOCITY;

    @Override
    public void runOpMode() {

        Shooter = hardwareMap.get(DcMotorEx.class, "Shooter");
        Shooter2 = hardwareMap.get(DcMotorEx.class, "Shooter2");
        Intake = hardwareMap.get(DcMotor.class, "Intake");
        Control = hardwareMap.get(DcMotor.class, "Control");
        LeftServo = hardwareMap.get(CRServo.class, "LeftServo");
        RightServo = hardwareMap.get(CRServo.class, "RightServo");

        Shooter.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        Shooter2.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);


        // Initialize controller
        flywheelController = new newPIDFController(kP, kI, kD, kF);
        flywheelController.setFeedforward(kV, kA, kS);

        // Set up FTC Dashboard telemetry
        FtcDashboard dashboard = FtcDashboard.getInstance();
        telemetry = new MultipleTelemetry(telemetry, dashboard.getTelemetry());

        telemetry.addData("Status", "Initialized - Ready to Tune!");
        telemetry.addData("Instructions", "Use D-Pad to change tuning mode");
        telemetry.addData("Instructions", "Use bumpers to adjust values");
        telemetry.update();

        // Get battery voltage
        VoltageSensor battery = hardwareMap.voltageSensor.iterator().next();
        batteryVoltage = battery.getVoltage();

        // Set motor modes
        Shooter.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        Shooter2.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);

        waitForStart();

        while (opModeIsActive()) {
            Intake.setPower(1);
            RightServo.setPower(1);
            LeftServo.setPower(1);
            Control.setPower(1);

            // ===== UPDATE GAMEPAD STATE =====
            previousGamepad1.copy(currentGamepad1);
            currentGamepad1.copy(gamepad1);

            // Update battery voltage
            batteryVoltage = battery.getVoltage();

            // ===== CONTROLLER-BASED TUNING =====
            handleControllerTuning();

            // ===== UPDATE PIDF CONTROLLER WITH CURRENT VALUES =====
            flywheelController.setPIDF(kP, kI, kD, kF);
            flywheelController.setFeedforward(kV, kA, kS);

            // ===== GET CURRENT VELOCITIES =====
            velocity1 = Shooter.getVelocity();
            velocity2 = Shooter2.getVelocity();
            double averageVelocity = (velocity1 + velocity2) / 2.0;

            // ===== CALCULATE CONTROL SIGNAL =====
            double error = targetVelocity - averageVelocity;
            double controlSignal = flywheelController.calculate(error, targetVelocity, 0);

            // Apply voltage compensation if enabled
            if (enableVoltageCompensation) {
                controlSignal = controlSignal * (nominalVoltage / Math.max(batteryVoltage, 1.0));
            }

            // Clamp control signal
            controlSignal = Math.max(-1.0, Math.min(controlSignal, 1.0));

            // ===== APPLY POWER TO MOTORS (ALWAYS RUNNING) =====
            Shooter.setPower(controlSignal);
            Shooter2.setPower(controlSignal);

            // ===== TELEMETRY =====
            displayTelemetry(controlSignal, error, averageVelocity);

            telemetry.update();
        }

        // Stop motors when OpMode ends
        Shooter.setPower(0);
        Shooter2.setPower(0);
    }

    /**
     * Handle controller-based tuning of parameters
     */
    private void handleControllerTuning() {
        // ===== CHANGE TUNING MODE WITH D-PAD =====
        if (currentGamepad1.dpad_up && !previousGamepad1.dpad_up) {
            currentMode = TuningMode.TARGET_VELOCITY;
        } else if (currentGamepad1.dpad_down && !previousGamepad1.dpad_down) {
            currentMode = TuningMode.KP;
        } else if (currentGamepad1.dpad_left && !previousGamepad1.dpad_left) {
            cycleModeBackward();
        } else if (currentGamepad1.dpad_right && !previousGamepad1.dpad_right) {
            cycleModeForward();
        }

        // ===== ADJUST CURRENT PARAMETER WITH BUMPERS =====
        boolean increase = currentGamepad1.right_bumper && !previousGamepad1.right_bumper;
        boolean decrease = currentGamepad1.left_bumper && !previousGamepad1.left_bumper;

        // Fine adjustment with triggers (continuous)
        double fineIncrease = currentGamepad1.right_trigger;
        double fineDecrease = currentGamepad1.left_trigger;

        if (increase || decrease || fineIncrease > 0.1 || fineDecrease > 0.1) {
            adjustParameter(increase, decrease, fineIncrease, fineDecrease);
        }

        // ===== QUICK VELOCITY PRESETS WITH A/B/X/Y =====
        if (currentGamepad1.a && !previousGamepad1.a) {
            targetVelocity = 1000.0;  // Low speed
        } else if (currentGamepad1.b && !previousGamepad1.b) {
            targetVelocity = 1240.0;  // Medium speed
        } else if (currentGamepad1.x && !previousGamepad1.x) {
            targetVelocity = 1500.0;  // High speed
        } else if (currentGamepad1.y && !previousGamepad1.y) {
            targetVelocity = 2000.0;  // Max speed
        }

        // ===== STOP MOTORS WITH BACK BUTTON =====
        if (currentGamepad1.back) {
            targetVelocity = 0.0;
        }

        // ===== RESET PARAMETERS WITH START BUTTON =====
        if (currentGamepad1.start && !previousGamepad1.start) {
            resetToDefaults();
        }
    }

    /**
     * Adjust the currently selected parameter
     */
    private void adjustParameter(boolean increase, boolean decrease, double fineIncrease, double fineDecrease) {
        double delta = 0;

        // Calculate delta based on input type
        if (increase) delta = 1.0;
        if (decrease) delta = -1.0;
        if (fineIncrease > 0.1) delta = fineIncrease * 0.5;
        if (fineDecrease > 0.1) delta = -fineDecrease * 0.5;

        switch (currentMode) {
            case TARGET_VELOCITY:
                targetVelocity += delta * velocityStep;
                targetVelocity = Math.max(0, targetVelocity);
                break;
            case KP:
                kP += delta * kP_increment;
                kP = Math.max(0, kP);
                break;
            case KI:
                kI += delta * kI_increment;
                kI = Math.max(0, kI);
                break;
            case KD:
                kD += delta * kD_increment;
                kD = Math.max(0, kD);
                break;
            case KV:
                kV += delta * kV_increment;
                kV = Math.max(0, kV);
                break;
            case KS:
                kS += delta * kS_increment;
                kS = Math.max(0, kS);
                break;
        }
    }

    /**
     * Cycle to the next tuning mode
     */
    private void cycleModeForward() {
        TuningMode[] modes = TuningMode.values();
        int currentIndex = currentMode.ordinal();
        currentMode = modes[(currentIndex + 1) % modes.length];
    }

    /**
     * Cycle to the previous tuning mode
     */
    private void cycleModeBackward() {
        TuningMode[] modes = TuningMode.values();
        int currentIndex = currentMode.ordinal();
        currentMode = modes[(currentIndex - 1 + modes.length) % modes.length];
    }

    /**
     * Reset all parameters to default values
     */
    private void resetToDefaults() {
        kP = 0.015;
        kI = 0.0;
        kD = 0.065067;
        kF = 0.0;
        kV = 0.00036;
        kA = 0.0;
        kS = 0.065067;
        targetVelocity = 1240.0;
    }

    /**
     * Display comprehensive telemetry
     */
    private void displayTelemetry(double controlSignal, double error, double averageVelocity) {
        telemetry.addData("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", "");
        telemetry.addData("ðŸŽ® CURRENT MODE", currentMode.toString());
        telemetry.addData("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", "");

        telemetry.addData("", "");
        telemetry.addData("--- FLYWHEEL STATUS ---", "");
        telemetry.addData("Target Velocity", "%.2f ticks/sec", targetVelocity);
        telemetry.addData("Shooter 1 Velocity", "%.2f ticks/sec", velocity1);
        telemetry.addData("Shooter 2 Velocity", "%.2f ticks/sec", velocity2);
        telemetry.addData("Average Velocity", "%.2f ticks/sec", averageVelocity);
        telemetry.addData("Error", "%.2f ticks/sec", error);
        telemetry.addData("Error %", "%.2f%%", (error / Math.max(targetVelocity, 1)) * 100);
        telemetry.addData("Control Signal", "%.4f", controlSignal);

        telemetry.addData("", "");
        telemetry.addData("--- PID COEFFICIENTS ---", "");
        telemetry.addData(currentMode == TuningMode.KP ? ">>> kP <<<" : "kP", "%.6f", kP);
        telemetry.addData(currentMode == TuningMode.KI ? ">>> kI <<<" : "kI", "%.6f", kI);
        telemetry.addData(currentMode == TuningMode.KD ? ">>> kD <<<" : "kD", "%.6f", kD);
        telemetry.addData("kF", "%.6f", kF);

        telemetry.addData("", "");
        telemetry.addData("--- FEEDFORWARD ---", "");
        telemetry.addData(currentMode == TuningMode.KV ? ">>> kV <<<" : "kV", "%.6f", kV);
        telemetry.addData("kA", "%.6f", kA);
        telemetry.addData(currentMode == TuningMode.KS ? ">>> kS <<<" : "kS", "%.6f", kS);

        telemetry.addData("", "");
        telemetry.addData("--- SYSTEM INFO ---", "");
        telemetry.addData("Battery Voltage", "%.2f V", batteryVoltage);
        telemetry.addData("Voltage Comp", enableVoltageCompensation ? "ON" : "OFF");
        telemetry.addData("Nominal Voltage", "%.2f V", nominalVoltage);

        telemetry.addData("", "");
        telemetry.addData("--- CONTROLS ---", "");
        telemetry.addData("D-Pad Up/Down", "Change mode");
        telemetry.addData("D-Pad Left/Right", "Cycle modes");
        telemetry.addData("Bumpers", "Adjust parameter (coarse)");
        telemetry.addData("Triggers", "Adjust parameter (fine)");
        telemetry.addData("A/B/X/Y", "Velocity presets");
        telemetry.addData("Back", "Stop motors");
        telemetry.addData("Start", "Reset to defaults");
    }
}
