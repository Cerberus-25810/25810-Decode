package org.firstinspires.ftc.teamcode.Meet3;

import com.pedropathing.follower.Follower;
import com.pedropathing.geometry.BezierLine;
import com.pedropathing.geometry.Pose;
import com.pedropathing.paths.PathChain;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.pedropathing.util.Timer;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.PIDFCoefficients;
import com.qualcomm.robotcore.util.ElapsedTime;

import org.firstinspires.ftc.teamcode.Meet1.mechanisms.FlywheelLogic;
import org.firstinspires.ftc.teamcode.pedroPathing.Constants;

@Autonomous(name = "BlueSideMeet3", group = "Autonomous")
public class BlueSideMeet3 extends OpMode {


    // ----------- FLYWHEEL SETUP --------------//

    private FlywheelLogic shooter = new FlywheelLogic();

    private ElapsedTime stateTimer = new ElapsedTime();

    private boolean shotsTriggered = false;

    private Follower follower;

    public static Pose AutoEndPose;

    private Timer pathTimer, opModeTimer;

    private DcMotorEx Shooter;

    private DcMotorEx Shooter2;
    private DcMotor Intake;
    private DcMotor Control;

    // Servos
    private CRServo LeftServo;
    private CRServo RightServo;



    public enum PathState {
        // START POSITION > END POSITION
        // DRIVE (MOVEMENT) STATE
        // SHOOT (ATTEMPT TO SCORE) STATE

        DRIVE_STARTPOS_TO_SHOOTPOS,
        SHOOT_PRELOAD,
        //        DRIVE_SHOOTPOS_ENDPOS //TESTING POSE
        DRIVE_SHOOTPOS_TO_PICKUPLINEUP,
        DRIVE_PICKUPLINEUP_TO_PICKUP,
        DRIVE_PICKUPPOS_SHOOTPOS,
        SHOOT_PRELOAD_2,

        DRIVE_SHOOTPOS_PICKUPLINEUPSECOND,

        DRIVE_PICKUPLINEUPSECOND_PICKUPSECOND,

        DRIVE_PICKUPSECOND_BACKUP,

        DRIVE_BACKUP_SHOOTPOS,

        SHOOT_PRELOAD_3
    }

    PathState pathState;


    // POSITION DECLARING
    private final Pose startPose = new Pose(21.792284866468844,124.34421364985162,Math.toRadians(143));
    private final Pose shootPose = new Pose(51,91, Math.toRadians(136));

    private final Pose endPose = new Pose(64,105,Math.toRadians(90)); //TESTING POSE

    private final Pose pickUpLineUpFirst = new Pose(47.5,83.8, Math.toRadians(180));
    private final Pose pickUpFirst = new Pose(21,81,Math.toRadians(180));

    private final Pose pickUpLineUpSecond = new Pose(45,60,Math.toRadians(180));

    private final Pose pickUpSecond = new Pose(11,60,Math.toRadians(180));

    private final Pose backup = new Pose(22,60, Math.toRadians(180));

    private PathChain drive_StartPos_ShootPos,drive_ShootPos_EndPos,drive_ShootPos_PickUpLineUpPos,drive_PickUpLineUpPos_PickUP,drive_PickUp_Shoot,drive_ShootPose_PickUpLineUpSecond,drive_PickUpLineUpSecond_PickUpSecond,drive_BackUp_ShootPos,drive_PickUpSecond_BackUp;

    public void buildPaths(){
        // Put in coordinates for starting pose to ending pose
        drive_StartPos_ShootPos = follower.pathBuilder()
                .addPath(new BezierLine(startPose, shootPose))
                .setLinearHeadingInterpolation(startPose.getHeading(), shootPose.getHeading())
                .build();

//        drive_ShootPos_EndPos = follower.pathBuilder()
//                .addPath(new BezierLine(shootPose,endPose))
//                .setLinearHeadingInterpolation(shootPose.getHeading(),endPose.getHeading())
//                .build();

        drive_ShootPos_PickUpLineUpPos = follower.pathBuilder()
                .addPath(new BezierLine(shootPose,pickUpLineUpFirst))
                .setLinearHeadingInterpolation(shootPose.getHeading(),endPose.getHeading())
                .build();

        drive_PickUpLineUpPos_PickUP = follower.pathBuilder()
                .addPath(new BezierLine(pickUpLineUpFirst,pickUpFirst))
                .setLinearHeadingInterpolation(pickUpLineUpFirst.getHeading(),pickUpFirst.getHeading())
                .build();

        drive_PickUp_Shoot = follower.pathBuilder()
                .addPath(new BezierLine(pickUpFirst,shootPose))
                .setLinearHeadingInterpolation(pickUpFirst.getHeading(),shootPose.getHeading())
                .build();

        drive_ShootPose_PickUpLineUpSecond = follower.pathBuilder()
                .addPath(new BezierLine(shootPose,pickUpLineUpSecond))
                .setLinearHeadingInterpolation(shootPose.getHeading(),pickUpLineUpSecond.getHeading())
                .build();

        drive_PickUpLineUpSecond_PickUpSecond = follower.pathBuilder()
                .addPath(new BezierLine(pickUpLineUpSecond,pickUpSecond))
                .setLinearHeadingInterpolation(pickUpLineUpSecond.getHeading(),pickUpSecond.getHeading())
                .build();

        drive_BackUp_ShootPos = follower.pathBuilder()
                .addPath(new BezierLine(pickUpSecond,shootPose))
                .setLinearHeadingInterpolation(pickUpSecond.getHeading(),shootPose.getHeading())
                .build();

        drive_PickUpSecond_BackUp = follower.pathBuilder()
                .addPath(new BezierLine(pickUpSecond,backup))
                .setLinearHeadingInterpolation(pickUpSecond.getHeading(),backup.getHeading())
                .build();


    }

    public void statePathUpdate(){
        switch(pathState){
            case DRIVE_STARTPOS_TO_SHOOTPOS:
                follower.setMaxPower(1);
                follower.followPath(drive_StartPos_ShootPos, true);
                setPathState(PathState.SHOOT_PRELOAD);//it will reset timer & switch state through func on line 81
                break;
            case SHOOT_PRELOAD:
                //check is follower done it's path and *3 sexconds has elapsed*
                if (!follower.isBusy() && pathTimer.getElapsedTimeSeconds() > 2){
                    //TODO: add shooting logic stuff liek rampup things and servo controls

                    if (!follower.isBusy()){
                        // requested shots yet?
                        if (!shotsTriggered){
                            shooter.fireShots(3);
                            shotsTriggered = true;
                        }
                        else if(shotsTriggered && !shooter.isBusy()){
                            //shots are done free to trasistion
                            setPathState(PathState.DRIVE_SHOOTPOS_TO_PICKUPLINEUP);
                        }
                    }
                }
                break;

            case DRIVE_SHOOTPOS_TO_PICKUPLINEUP:
                follower.followPath(drive_ShootPos_PickUpLineUpPos,true);
                setPathState(PathState.DRIVE_PICKUPLINEUP_TO_PICKUP);
                stateTimer.reset();
                break;
            case DRIVE_PICKUPLINEUP_TO_PICKUP:
                if(!follower.isBusy()) {
                    follower.followPath(drive_PickUpLineUpPos_PickUP,true);
                    setPathState(PathState.DRIVE_PICKUPPOS_SHOOTPOS);
                    stateTimer.reset();
                }
                break;
            case DRIVE_PICKUPPOS_SHOOTPOS:
                if(!follower.isBusy()){
                    follower.followPath(drive_PickUp_Shoot);
                    telemetry.addLine("last path done");
                    stateTimer.reset();
                    setPathState(PathState.SHOOT_PRELOAD_2);
                }
                break;
            case SHOOT_PRELOAD_2:
                if (!follower.isBusy()){

                    if (!follower.isBusy()){
                        // requested shots yet?
                        if (!shotsTriggered){
                            shooter.fireShots(3);
                            shotsTriggered = true;
                        }
                        else if(shotsTriggered && !shooter.isBusy()){
                            //shots are done free to trasistion
                            setPathState(PathState.DRIVE_SHOOTPOS_PICKUPLINEUPSECOND);
                        }
                    }
                }
                break;

            case DRIVE_SHOOTPOS_PICKUPLINEUPSECOND:
                if(!follower.isBusy()){
                    follower.followPath(drive_ShootPose_PickUpLineUpSecond, true);
                    setPathState(PathState.DRIVE_PICKUPLINEUPSECOND_PICKUPSECOND);//it will reset timer & switch state through func on line 81

                }
                break;

            case DRIVE_PICKUPLINEUPSECOND_PICKUPSECOND:
                if(!follower.isBusy()){
                    follower.followPath(drive_PickUpLineUpSecond_PickUpSecond, true);
                    setPathState(PathState.DRIVE_PICKUPSECOND_BACKUP);

                }
                break;

            case DRIVE_PICKUPSECOND_BACKUP:
                if(!follower.isBusy()){
                    follower.followPath(drive_PickUpSecond_BackUp,true);
                    setPathState(PathState.DRIVE_BACKUP_SHOOTPOS);
                }

            case DRIVE_BACKUP_SHOOTPOS:
                if(!follower.isBusy()){
                    follower.followPath(drive_BackUp_ShootPos, true);
                    setPathState(PathState.SHOOT_PRELOAD_3);

                }
                break;

            case SHOOT_PRELOAD_3:

                if (!follower.isBusy()){
                    //TODO: add shooting logic stuff liek rampup things and servo controls

                    if (!follower.isBusy()){
                        // requested shots yet?
                        if (!shotsTriggered){
                            shooter.fireShots(3);
                            shotsTriggered = true;
                        }
                        else if(shotsTriggered && !shooter.isBusy()){
                            //shots are done free to trasistion
//                            setPathState(PathState.DRIVE_SHOOTPOS_TO_PICKUPLINEUP);
                        }
                    }
                }
                break;



            default:
                telemetry.addLine("No State Commanded");
                break;
        }
    }

    public void setPathState(PathState newState){
        pathState = newState;
        pathTimer.resetTimer();

        shotsTriggered = false;
    }

    @Override
    public void init() {
        pathState = PathState.DRIVE_STARTPOS_TO_SHOOTPOS;
        pathTimer = new Timer();
        opModeTimer = new Timer();
        //opModeTimer.resetTimer();
        follower = Constants.createFollower(hardwareMap);
        // TODO add in any other init mechanisims like flyweel and servos and ctrl motors
        Shooter = hardwareMap.get(DcMotorEx.class, "Shooter");
        Intake = hardwareMap.get(DcMotor.class, "Intake");
        Control = hardwareMap.get(DcMotor.class, "Control");
        Shooter2 = hardwareMap.get(DcMotorEx.class,"Shooter2");

        // Set Control motor to use encoder for position control
        Control.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        Control.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        // Initialize servos
        LeftServo = hardwareMap.get(CRServo.class, "LeftServo");
        RightServo = hardwareMap.get(CRServo.class, "RightServo");

        // Set servo directions - adjust if servos move in opposite directions
        LeftServo.setDirection(CRServo.Direction.FORWARD);
        RightServo.setDirection(CRServo.Direction.REVERSE);

        // Set motor directions (adjust these based on your robot's configuration)
        Shooter.setDirection(DcMotorSimple.Direction.REVERSE);
        Shooter2.setDirection(DcMotorSimple.Direction.FORWARD);
        Control.setDirection(DcMotorSimple.Direction.REVERSE);
        shooter.init(hardwareMap);

        Shooter.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        Shooter2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);


        PIDFCoefficients SHOOTERpidfCoefficients = new PIDFCoefficients(0.005,0,0,15.5);
        Shooter.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER,SHOOTERpidfCoefficients);
        Shooter2.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER,SHOOTERpidfCoefficients);

        buildPaths();
        follower.setPose(startPose);
    }

    public void start(){
        try {
            Thread.sleep(400); // 400ms delay
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        opModeTimer.resetTimer();
        setPathState(pathState);
        Shooter.setVelocity(1150);
        Shooter2.setVelocity(1150);
        Control.setPower(0.3);
        Intake.setPower(1);
        LeftServo.setPower(-1);
        RightServo.setPower(-1);


    }

    @Override
    public void loop(){
        AutoEndPose = follower.getPose();
        follower.update();
        shooter.update();
        statePathUpdate();


        telemetry.addData("path state", pathState.toString());
        telemetry.addData("x", follower.getPose().getX());
        telemetry.addData("y",follower.getPose().getY());
        telemetry.addData("heading", follower.getPose().getHeading());
        telemetry.addData("Path time", pathTimer.getElapsedTimeSeconds());

    }

}
