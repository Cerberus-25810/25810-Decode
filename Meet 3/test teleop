package org.firstinspires.ftc.teamcode;

import static org.firstinspires.ftc.teamcode.pedroPathing.Tuning.follower;

import com.pedropathing.geometry.BezierLine;
import com.pedropathing.geometry.Pose;
import com.pedropathing.paths.Path;
import com.pedropathing.paths.PathChain;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.PIDFCoefficients;
import com.qualcomm.robotcore.hardware.ServoImplEx;
import com.qualcomm.robotcore.hardware.PwmControl;
import com.qualcomm.robotcore.util.ElapsedTime;

import org.firstinspires.ftc.teamcode.pedroPathing.Constants;
import static org.firstinspires.ftc.teamcode.Meet3.BlueSideMeet3.AutoEndPose;

import java.util.function.Supplier;

/**
 * RAPID FIRE TELEOP
 *
 * This TeleOp implements:
 * - Pedro Pathing for accurate localization
 * - Auto-aim heading lock that tracks the goal
 * - Lead compensation for accurate shots while moving
 * - Rapid fire shooting with minimal delay
 * - Battery-optimized code with cached calculations
 *
 * CONTROLS:
 * - Left Stick: Drive (robot-centric)
 * - Right Stick: Turn (when not heading locked)
 * - X (HOLD): Rapid fire all balls
 * - Y: Toggle heading lock (face goal)
 * - A: Auto-drive to starting position
 * - B: Cancel auto-drive
 * - RT: Intake
 * - LT: Reverse/unjam
 */
@TeleOp(name="Rapid Fire TeleOp", group="TeleOp")
public class intertele extends OpMode {

    // ==================== CONSTANTS ====================

    /**
     * Goal position coordinates (inches)
     * This is the target we aim at - the basket/goal on the field
     */
    private static final double GOAL_X = 13.0;
    private static final double GOAL_Y = 135.0;

    /**
     * Return position for A button auto-drive
     * This is where the robot goes when you press A
     */
    private static final Pose RETURN_POSE = new Pose(51, 91, Math.toRadians(143));

    /**
     * Default starting pose if autonomous didn't run
     */
    private final Pose startPose = new Pose(51, 91, Math.toRadians(143));

    // ==================== HEADING LOCK CONFIGURATION ====================

    /**
     * Heading offset calibration value
     * This corrects for the difference between atan2 output and Pedro Pathing's heading
     * Calculated from: at (51,91) facing goal (13,135), heading = 143Â°
     * atan2(44, -38) â‰ˆ 130.8Â°, so offset = 143 - 130.8 â‰ˆ 12.2Â°
     */
    private static final double HEADING_OFFSET = 12.2;

    /**
     * PD Controller constants for heading lock
     * - kP: Proportional gain - how aggressively to turn toward target
     * - kD: Derivative gain - dampens oscillation
     * Higher kP = faster response but more overshoot
     * Higher kD = smoother but slower response
     */
    private static final double kP = 0.015;   // Slightly increased for snappier response
    private static final double kD = 0.008;   // Increased to dampen overshoot
    private static final double MAX_TURN_POWER = 0.6;   // Max turn speed
    private static final double DEADBAND_DEGREES = 1.0; // Stop adjusting when this close

    /**
     * LEAD COMPENSATION for moving shots
     * When the robot is moving, we need to aim ahead of where we are
     * This factor determines how much to lead the target based on velocity
     * Higher = more lead (for faster projectiles, use less lead)
     */
    private static final double LEAD_FACTOR = 0.4;  // Tune this based on ball flight time

    // ==================== RAPID FIRE CONFIGURATION ====================

    /**
     * Delay before servos engage (seconds)
     * Reduced from 0.1 to 0.05 for FASTER shooting
     * This gives the control motor a brief head start
     */
    private static final double SERVO_DELAY = 0.01;

    // ==================== INTERPOLATION TABLES ====================

    /**
     * Shooter velocity lookup table
     * Format: {distance (inches), velocity (ticks/sec)}
     * Values are linearly interpolated between points
     */
    private static final double[][] SHOOTER_TABLE = {
            {40,    900},
            {58,    1000},
            {86,    1140},
            {87.5,  1140},
            {124,   1360}
    };

    /**
     * Hood position lookup table
     * Format: {distance (inches), servo position (0-1)}
     * Higher values = more angled hood for longer shots
     */
    private static final double[][] HOOD_TABLE = {
            {40,    0.000},
            {58,    0.167},
            {86,    0.220},
            {87.5,  0.250},
            {124,   0.250}
    };

    /**
     * Battery compensation - adds extra RPM to account for voltage drop
     * Increase this if shots fall short as battery drains
     */
    private static final double BATTERY_COMPENSATION_RPM = 100.0;

    // ==================== HARDWARE OBJECTS ====================
    // Cached references to avoid repeated hardwareMap lookups

    private DcMotorEx Shooter, Shooter2;  // Flywheel motors (velocity controlled)
    private DcMotor Intake, Control;       // Intake and ball control motors
    private CRServo LeftServo, RightServo; // Ball feeding servos
    private ServoImplEx Hood;              // Adjustable hood servo

    // ==================== STATE VARIABLES ====================

    // Heading lock state
    private boolean headingLocked = false;
    private boolean lastY = false;           // For Y button edge detection
    private double lastError = 0;            // Previous error for derivative
    private final ElapsedTime pidTimer = new ElapsedTime();

    // Automated driving state
    private boolean automatedDrive = false;
    private Supplier<PathChain> returnPath;  // Lazy path generation

    // Rapid fire state
    private final ElapsedTime shootTimer = new ElapsedTime();
    private boolean shootPressed = false;

    // ==================== CACHED VALUES ====================
    // These prevent redundant calculations each loop

    // ==================== INITIALIZATION ====================

    @Override
    public void init() {
        // Initialize Pedro Pathing follower for localization
        follower = Constants.createFollower(hardwareMap);

        // Cache all hardware references (more efficient than repeated lookups)
        initializeHardware();

        // Configure motor directions, modes, and PIDF coefficients
        configureMotors();

        // Configure servo directions and PWM ranges
        configureServos();

        // Set starting pose from autonomous if available
        // This ensures smooth transition from auto to teleop
        try {
            follower.setStartingPose(AutoEndPose != null ? AutoEndPose : startPose);
        } catch (Exception e) {
            follower.setStartingPose(startPose);
        }
        follower.update();

        // Create lazy path supplier
        // This generates a fresh path from current position each time A is pressed
        returnPath = () -> follower.pathBuilder()
                .addPath(new Path(new BezierLine(follower.getPose(), RETURN_POSE)))
                .setLinearHeadingInterpolation(follower.getPose().getHeading(), RETURN_POSE.getHeading())
                .build();

        telemetry.addData("Status", "âœ“ Initialized");
        telemetry.addLine("X=Shoot | Y=Lock | A=Return | B=Cancel");
        telemetry.update();
    }

    /**
     * Cache all hardware references
     * Doing this once in init() is more efficient than calling hardwareMap.get() repeatedly
     */
    private void initializeHardware() {
        Shooter = hardwareMap.get(DcMotorEx.class, "Shooter");
        Shooter2 = hardwareMap.get(DcMotorEx.class, "Shooter2");
        Intake = hardwareMap.get(DcMotor.class, "Intake");
        Control = hardwareMap.get(DcMotor.class, "Control");

        LeftServo = hardwareMap.get(CRServo.class, "LeftServo");
        RightServo = hardwareMap.get(CRServo.class, "RightServo");
        Hood = hardwareMap.get(ServoImplEx.class, "Hood");
    }

    /**
     * Configure motor directions, encoder modes, and PIDF coefficients
     */
    private void configureMotors() {
        // Set motor directions based on hardware mounting
        Shooter.setDirection(DcMotorSimple.Direction.REVERSE);
        Shooter2.setDirection(DcMotorSimple.Direction.FORWARD);
        Control.setDirection(DcMotorSimple.Direction.REVERSE);

        // Reset and configure encoder modes
        Control.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        Control.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        Shooter.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        Shooter2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        // PIDF coefficients for velocity control on shooters
        // Tuned for consistent flywheel speed regardless of load
        PIDFCoefficients shooterPIDF = new PIDFCoefficients(0.015, 0, 0.017, 17.2900);
        Shooter.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, shooterPIDF);
        Shooter2.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, shooterPIDF);
    }

    /**
     * Configure servo directions and extended PWM range for Axon servo
     */
    private void configureServos() {
        // Extended PWM range for Axon servo (500-2500 vs standard 1000-2000)
        Hood.setPwmRange(new PwmControl.PwmRange(500, 2500));
        Hood.setPosition(0);

        // Set servo directions so they spin the correct way
        LeftServo.setDirection(CRServo.Direction.FORWARD);
        RightServo.setDirection(CRServo.Direction.REVERSE);
    }

    @Override
    public void start() {
        // Start Pedro Pathing TeleOp drive mode
        follower.startTeleopDrive();
        pidTimer.reset();
    }

    // ==================== MAIN LOOP ====================

    @Override
    public void loop() {
        // Update odometry/localization
        follower.update();
        Pose curPose = follower.getPose();

        // Calculate distance to goal (cached for efficiency)
        double deltaX = GOAL_X - curPose.getX();
        double deltaY = GOAL_Y - curPose.getY();
        // Last calculated distance to goal
        double cachedDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

        // ==================== DRIVE CONTROLS ====================

        double drive = -gamepad1.left_stick_y;
        double strafe = -gamepad1.left_stick_x;
        double turn = -gamepad1.right_stick_x;

        if (!automatedDrive) {
            // Apply heading lock if enabled (overrides turn stick)
            if (headingLocked) {
                turn = calculateGoalLockTurn(curPose);
            }

            // Send drive commands to Pedro Pathing
            follower.setTeleOpDrive(drive, strafe, turn, true);
        }

        // Y button - Toggle heading lock with edge detection
        if (gamepad1.y && !lastY) {
            headingLocked = !headingLocked;
            if (headingLocked) {
                // Reset PD state when enabling
                lastError = 0;
                pidTimer.reset();
            }
        }
        lastY = gamepad1.y;

        // A button - Auto-drive to starting position
        if (gamepad1.a && !automatedDrive) {
            follower.followPath(returnPath.get());
            automatedDrive = true;
            headingLocked = false;
        }

        // B button - Cancel automated driving OR auto-complete when done
        if (automatedDrive && (gamepad1.b || !follower.isBusy())) {
            follower.startTeleopDrive();
            automatedDrive = false;
        }

        // ==================== FLYWHEEL (ALWAYS RUNNING) ====================
        // Keep flywheels spinning for instant shots
        // Only recalculate if distance changed significantly (battery optimization)

        // Last calculated shooter speed
        double cachedShooterVelocity = calculateShooterVelocity(cachedDistance);
        // Last calculated hood position
        double cachedHoodPosition = calculateHoodPosition(cachedDistance);

        Shooter.setVelocity(cachedShooterVelocity);
        Shooter2.setVelocity(cachedShooterVelocity);
        Hood.setPosition(cachedHoodPosition);

        // ==================== MOTOR/SERVO CONTROL ====================

        double controlPower;
        double intakePower = 0;
        double servoSpeed = -1.0;

// PRIORITY 1: Left trigger - Reverse/Unjam
        if (gamepad1.left_trigger > 0.1) {
            intakePower = -1.0;
            controlPower = -0.5;
            shootPressed = false;
        }
// PRIORITY 2: X button - RAPID FIRE
        else if (gamepad1.x) {
            if (!shootPressed) {
                shootTimer.reset();
                shootPressed = true;
            }

            controlPower = 1.0;

            if (shootTimer.seconds() >= SERVO_DELAY) {
                servoSpeed = 1.0;
            }

            if (gamepad1.right_trigger > 0.1) {
                intakePower = 1.0;
            }
        }
// PRIORITY 3: Right trigger - Intake only
        else if (gamepad1.right_trigger > 0.1) {
            intakePower = 1.0;
            controlPower = 0.5;    // FIX: Ensure control motor is OFF during intake
            servoSpeed = -1.0;      // FIX: Ensure servos are OFF during intake
        }
// IDLE - Everything off
        else {
            shootPressed = false;
            controlPower = 0;    // FIX: Explicitly stop control motor
            servoSpeed = 0;      // FIX: Explicitly stop servos
        }

// Apply powers
        Intake.setPower(intakePower);
        Control.setPower(controlPower);
        LeftServo.setPower(servoSpeed);
        RightServo.setPower(servoSpeed);

        // ==================== TELEMETRY (CONDENSED) ====================

        telemetry.addData("Mode", automatedDrive ? "ðŸ¤– AUTO" :
                (headingLocked ? "ðŸŽ¯ LOCKED" : "Manual"));
        telemetry.addData("Pos", "(%.0f, %.0f) %.0fÂ°",
                curPose.getX(), curPose.getY(), Math.toDegrees(curPose.getHeading()));
        telemetry.addData("Dist", "%.0f in | RPM: %.0f", cachedDistance, cachedShooterVelocity);

        if (gamepad1.x) telemetry.addLine("ðŸ”¥ SHOOTING");

        telemetry.update();
    }

    // ==================== HEADING LOCK WITH LEAD COMPENSATION ====================

    /**
     * Calculate turn power to face the goal using PD control
     * Includes LEAD COMPENSATION for accurate shots while moving
     *
     * @param currentPose Current robot pose from odometry
     * @return Turn power from -MAX_TURN_POWER to MAX_TURN_POWER
     */
    private double calculateGoalLockTurn(Pose currentPose) {
        // Get robot velocity for lead compensation
        // When moving, we need to aim ahead of our current position
        double velocityX = 0;
        double velocityY = 0;

        try {
            // Pedro Pathing provides velocity information
            velocityX = follower.getVelocity().getXComponent();
            velocityY = follower.getVelocity().getYComponent();
        } catch (Exception e) {
            // Fallback if velocity not available
        }

        // Calculate where we WILL BE, not where we ARE
        // This compensates for robot movement during ball flight
        double predictedX = currentPose.getX() + velocityX * LEAD_FACTOR;
        double predictedY = currentPose.getY() + velocityY * LEAD_FACTOR;

        // Calculate angle from PREDICTED position to goal
        double deltaX = GOAL_X - predictedX;
        double deltaY = GOAL_Y - predictedY;

        // Normalize current heading to 0-360
        double currentHeading = Math.toDegrees(currentPose.getHeading());
        while (currentHeading < 0) currentHeading += 360;
        while (currentHeading >= 360) currentHeading -= 360;

        // Calculate target heading with calibration offset
        double targetHeading = Math.toDegrees(Math.atan2(deltaY, deltaX)) + HEADING_OFFSET;
        while (targetHeading < 0) targetHeading += 360;
        while (targetHeading >= 360) targetHeading -= 360;

        // Calculate error (shortest path, -180 to 180)
        double error = targetHeading - currentHeading;
        while (error > 180) error -= 360;
        while (error < -180) error += 360;

        // PD Controller calculation
        double deltaTime = pidTimer.seconds();
        pidTimer.reset();

        double P = error * kP;
        double D = 0;
        if (deltaTime > 0.001) {
            double derivative = (error - lastError) / deltaTime;
            // Clamp derivative to prevent spikes
            derivative = Math.max(-50, Math.min(50, derivative));
            D = derivative * kD;
        }
        lastError = error;

        // Calculate and clamp output
        double turnOutput = P + D;
        turnOutput = Math.max(-MAX_TURN_POWER, Math.min(MAX_TURN_POWER, turnOutput));

        // Apply deadband - stop jittering when close enough
        if (Math.abs(error) < DEADBAND_DEGREES) {
            turnOutput = 0;
        }

        return turnOutput;
    }

    // ==================== INTERPOLATION METHODS ====================

    /**
     * Linear interpolation between table values
     * Given a distance, finds the two closest points and interpolates
     *
     * @param table 2D array of {distance, value} pairs
     * @param distance Current distance to goal
     * @return Interpolated value
     */
    private double interpolate(double[][] table, double distance) {
        // Handle edge cases (outside table range)
        if (distance <= table[0][0]) return table[0][1];
        if (distance >= table[table.length - 1][0]) return table[table.length - 1][1];

        // Find the two points to interpolate between
        for (int i = 0; i < table.length - 1; i++) {
            if (distance >= table[i][0] && distance <= table[i + 1][0]) {
                double x0 = table[i][0];
                double y0 = table[i][1];
                double x1 = table[i + 1][0];
                double y1 = table[i + 1][1];

                // Linear interpolation formula: y = y0 + (y1-y0) * (x-x0) / (x1-x0)
                return y0 + (y1 - y0) * (distance - x0) / (x1 - x0);
            }
        }

        return table[0][1];
    }

    /**
     * Calculate shooter velocity based on distance
     * Uses interpolation table + battery compensation
     */
    private double calculateShooterVelocity(double distance) {
        double baseVelocity = interpolate(SHOOTER_TABLE, distance);
        return baseVelocity + BATTERY_COMPENSATION_RPM;
    }

    /**
     * Calculate hood position based on distance
     * Uses interpolation table for smooth adjustment
     */
    private double calculateHoodPosition(double distance) {
        return interpolate(HOOD_TABLE, distance);
    }
}
