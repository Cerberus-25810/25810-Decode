package org.firstinspires.ftc.teamcode;

import static org.firstinspires.ftc.teamcode.pedroPathing.Tuning.follower;

import com.acmerobotics.dashboard.config.Config;
import com.pedropathing.geometry.BezierLine;
import com.pedropathing.geometry.Pose;
import com.pedropathing.paths.Path;
import com.pedropathing.paths.PathChain;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.PIDFCoefficients;
import com.qualcomm.robotcore.hardware.ServoImplEx;
import com.qualcomm.robotcore.hardware.PwmControl;
import com.qualcomm.robotcore.util.ElapsedTime;

import org.firstinspires.ftc.teamcode.pedroPathing.Constants;
import static org.firstinspires.ftc.teamcode.Meet3.BlueSideMeet3.AutoEndPose;

import java.util.function.Supplier;

/**
 * RAPID FIRE TELEOP
 *
 * This TeleOp implements:
 * - Pedro Pathing for accurate localization
 * - Auto-aim heading lock that tracks the goal
 * - Distance-adaptive goal positioning for better accuracy
 * - Rapid fire shooting with minimal delay
 * - Battery-optimized code with cached calculations
 *
 * CONTROLS:
 * - Left Stick: Drive (robot-centric)
 * - Right Stick: Turn (when not heading locked)
 * - Y: Toggle heading lock (face goal)
 * - A: Auto-drive to starting position
 * - B: Cancel auto-drive
 * - RT: Rapid Shoot
 * - LT: Reverse/unjam
 */
@TeleOp(name="bombo", group="TeleOp")
public class bombo extends OpMode {

    // ==================== CONSTANTS ====================

    /**
     * Goal position coordinates for close/medium range (inches)
     */
    private static final double GOAL_X_CLOSE = 13.0;
    private static final double GOAL_Y_CLOSE = 135.0;

    /**
     * Goal position coordinates for far range (>90 inches)
     */
    private static final double GOAL_X_FAR = 25.0;
    private static final double GOAL_Y_FAR = 140.0;

    /**
     * Distance threshold to switch goal positions
     */
    private static final double DISTANCE_THRESHOLD = 90.0;

    /**
     * Return position for A button auto-drive
     */
    private static final Pose RETURN_POSE = new Pose(51, 91, Math.toRadians(143));

    /**
     * Default starting pose if autonomous didn't run
     */
    private final Pose startPose = new Pose(51, 91, Math.toRadians(143));

    // ==================== HEADING LOCK CONFIGURATION ====================

    /**
     * Heading offset calibration value
     */
    private static final double HEADING_OFFSET = 12.2;

    /**
     * PD Controller constants for heading lock
     */
    private static final double kP = 0.03;
    private static final double kD = 0.01;
    private static final double MAX_TURN_POWER = 0.7;
    private static final double DEADBAND_DEGREES = 1.0;

    // ==================== HARDWARE OBJECTS ====================

    private DcMotorEx Shooter, Shooter2;
    private DcMotor Intake, Control;
    private CRServo LeftServo, RightServo;
    private ServoImplEx Hood;

    // ==================== STATE VARIABLES ====================

    private boolean headingLocked = false;
    private boolean lastY = false;
    private double lastError = 0;
    private final ElapsedTime pidTimer = new ElapsedTime();

    private boolean automatedDrive = false;
    private Supplier<PathChain> returnPath;

    private final ElapsedTime shootTimer = new ElapsedTime();

    // ==================== INITIALIZATION ====================

    @Override
    public void init() {
        follower = Constants.createFollower(hardwareMap);
        initializeHardware();
        configureMotors();
        configureServos();

        try {
            follower.setStartingPose(AutoEndPose != null ? AutoEndPose : startPose);
        } catch (Exception e) {
            follower.setStartingPose(startPose);
        }
        follower.update();

        returnPath = () -> follower.pathBuilder()
                .addPath(new Path(new BezierLine(follower.getPose(), RETURN_POSE)))
                .setLinearHeadingInterpolation(follower.getPose().getHeading(), RETURN_POSE.getHeading())
                .build();

        telemetry.addData("Status", "âœ“ Initialized");
        telemetry.addLine("Y=Lock | A=Return | B=Cancel");
        telemetry.addLine("Goal switches at 90+ inches");
        telemetry.update();
    }

    private void initializeHardware() {
        Shooter = hardwareMap.get(DcMotorEx.class, "Shooter");
        Shooter2 = hardwareMap.get(DcMotorEx.class, "Shooter2");
        Intake = hardwareMap.get(DcMotor.class, "Intake");
        Control = hardwareMap.get(DcMotor.class, "Control");
        LeftServo = hardwareMap.get(CRServo.class, "LeftServo");
        RightServo = hardwareMap.get(CRServo.class, "RightServo");
        Hood = hardwareMap.get(ServoImplEx.class, "Hood");
    }

    private void configureMotors() {
        Shooter.setDirection(DcMotorSimple.Direction.REVERSE);
        Shooter2.setDirection(DcMotorSimple.Direction.FORWARD);
        Control.setDirection(DcMotorSimple.Direction.REVERSE);

        Control.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        Control.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        Shooter.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        Shooter2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        PIDFCoefficients shooterPIDF = new PIDFCoefficients(0.015, 0, 0.017, 17.2900);
        Shooter.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, shooterPIDF);
        Shooter2.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, shooterPIDF);
    }

    private void configureServos() {
        Hood.setPwmRange(new PwmControl.PwmRange(500, 2500));
        Hood.setPosition(0);
        LeftServo.setDirection(CRServo.Direction.FORWARD);
        RightServo.setDirection(CRServo.Direction.REVERSE);
    }

    @Override
    public void start() {
        follower.startTeleopDrive();
        pidTimer.reset();
    }

    // ==================== MAIN LOOP ====================

    @Override
    public void loop() {
        follower.update();
        Pose curPose = follower.getPose();

        // Calculate initial distance to determine which goal to use
        double deltaX_initial = GOAL_X_CLOSE - curPose.getX();
        double deltaY_initial = GOAL_Y_CLOSE - curPose.getY();
        double initialDistance = Math.sqrt(deltaX_initial * deltaX_initial + deltaY_initial * deltaY_initial);

        // Select goal based on distance
        double activeGoalX, activeGoalY;
        boolean usingFarGoal = initialDistance > DISTANCE_THRESHOLD;

        if (usingFarGoal) {
            activeGoalX = GOAL_X_FAR;
            activeGoalY = GOAL_Y_FAR;
        } else {
            activeGoalX = GOAL_X_CLOSE;
            activeGoalY = GOAL_Y_CLOSE;
        }

        // Recalculate distance with selected goal
        double deltaX = activeGoalX - curPose.getX();
        double deltaY = activeGoalY - curPose.getY();
        double cachedDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

        // ==================== DRIVE CONTROLS ====================

        double drive = -gamepad1.left_stick_y;
        double strafe = -gamepad1.left_stick_x;
        double turn = -gamepad1.right_stick_x;

        if (!automatedDrive) {
            if (headingLocked) {
                turn = calculateGoalLockTurn(curPose, activeGoalX, activeGoalY);
            }
            follower.setTeleOpDrive(drive, strafe, turn, true);
        }

        // Y button - Toggle heading lock
        if (gamepad1.y && !lastY) {
            headingLocked = !headingLocked;
            if (headingLocked) {
                lastError = 0;
                pidTimer.reset();
            }
        }
        lastY = gamepad1.y;

        // A button - Auto-drive to starting position
        if (gamepad1.a && !automatedDrive) {
            follower.followPath(returnPath.get());
            automatedDrive = true;
            headingLocked = false;
        }

        // B button - Cancel automated driving
        if (automatedDrive && (gamepad1.b || !follower.isBusy())) {
            follower.startTeleopDrive();
            automatedDrive = false;
        }

        // ==================== FLYWHEEL ====================

        double cachedShooterVelocity = calculateShooterVelocity(cachedDistance);
        double cachedHoodPosition = calculateHoodPosition(cachedDistance);

        Shooter.setVelocity(cachedShooterVelocity);
        Shooter2.setVelocity(cachedShooterVelocity);
        Hood.setPosition(cachedHoodPosition);

        // ==================== MOTOR/SERVO CONTROL ====================

        double controlPower = 0.5;
        double intakePower = 0.7;
        double servoSpeed = -0.5;

        if (gamepad1.left_trigger > 0.2) {
            intakePower = -1.0;
            controlPower = -0.5;
        } else if (gamepad1.right_trigger > 0.2) {
            intakePower = 1.0;
            controlPower = 1.0;
            servoSpeed = 1.0;
        }

        Intake.setPower(intakePower);
        Control.setPower(controlPower);
        LeftServo.setPower(servoSpeed);
        RightServo.setPower(servoSpeed);

        // ==================== TELEMETRY ====================

        telemetry.addData("Mode", automatedDrive ? "ðŸ¤– AUTO" :
                (headingLocked ? "ðŸŽ¯ LOCKED" : "Manual"));
        telemetry.addData("Pos", "(%.0f, %.0f) %.0fÂ°",
                curPose.getX(), curPose.getY(), Math.toDegrees(curPose.getHeading()));
        telemetry.addData("Goal", usingFarGoal ? "FAR (%.0f,%.0f)" : "CLOSE (%.0f,%.0f)",
                activeGoalX, activeGoalY);
        telemetry.addData("Dist", "%.0f in | RPM: %.0f", cachedDistance, cachedShooterVelocity);

        if (gamepad1.x) telemetry.addLine("ðŸ”¥ SHOOTING");

        telemetry.update();
    }

    // ==================== HEADING LOCK ====================

    /**
     * Calculate turn power to face the goal using PD control
     */
    private double calculateGoalLockTurn(Pose currentPose, double goalX, double goalY) {
        double deltaX = goalX - currentPose.getX();
        double deltaY = goalY - currentPose.getY();

        double currentHeading = Math.toDegrees(currentPose.getHeading());
        while (currentHeading < 0) currentHeading += 360;
        while (currentHeading >= 360) currentHeading -= 360;

        double targetHeading = Math.toDegrees(Math.atan2(deltaY, deltaX)) + HEADING_OFFSET;
        while (targetHeading < 0) targetHeading += 360;
        while (targetHeading >= 360) targetHeading -= 360;

        double error = targetHeading - currentHeading;
        while (error > 180) error -= 360;
        while (error < -180) error += 360;

        double deltaTime = pidTimer.seconds();
        pidTimer.reset();

        double P = error * kP;
        double D = 0;
        if (deltaTime > 0.001) {
            double derivative = (error - lastError) / deltaTime;
            derivative = Math.max(-50, Math.min(50, derivative));
            D = derivative * kD;
        }
        lastError = error;

        double turnOutput = P + D;
        turnOutput = Math.max(-MAX_TURN_POWER, Math.min(MAX_TURN_POWER, turnOutput));

        if (Math.abs(error) < DEADBAND_DEGREES) {
            turnOutput = 0;
        }

        return turnOutput;
    }

    // ==================== REGRESSION METHODS ====================

    private double calculateShooterVelocity(double distance) {
        if (distance < 1) distance = 1;
        double velocity = 0.00360311 * Math.pow(distance, 2) + 4.69347 * distance + 723.99696;
        if (velocity < 850) velocity = 850;
        if (velocity > 1500) velocity = 1500;
        return velocity;
    }

    private double calculateHoodPosition(double distance) {
        double position = 0.00000214104 * Math.pow(distance, 3) - 0.000576537 * Math.pow(distance, 2) + 0.0518886 * distance - 1.28608;
        if (position < 0.0) position = 0.0;
        if (position > 0.350) position = 0.350;
        return position;
    }
}
